# TSera app-minimal

This is the template shipped with `tsera init`. It includes:

- A ready-to-run Hono API (`main.ts` + `app/routes/health.route.ts`).
- An example entity (`domain/User.entity.ts`) managed by TSera.
- A minimal Fresh SSR frontend (`web/`).
- A fully documented `tsera.config.ts` generated automatically.
- Smoke tests (`tests/health.test.ts`).

## Quick start

```bash
# Generate artifacts (Zod, OpenAPI, migrations, docs, tests)
tsera dev --once

# Start the Hono API (http://localhost:8000) and Fresh (http://localhost:8001)
deno task dev

# Check the health route
curl http://localhost:8000/health
```

The Fresh page in `web/routes/index.tsx` lists the next steps to connect the UI with the backend.
Log lines are prefixed with `[api]` and `[web]` so you know which watcher produced each message.
When you only need one side, use `deno task dev:api` or `deno task dev:web` directly.

## Config & import map

- `tsera.config.ts` exposes every engine option. The template also registers a `jsr:@tsera/core`
  alias in `import_map.json` pointing to `tsera-core.ts`, a local contract that keeps the project
  compiling until the official package is published. Replace the alias with the real dependency as
  soon as it becomes available.
- Other aliases (`tsera/`, `@fresh/`, `@preact/`, `@std/`) are already configured for Deno.

## Next steps

- Add your entities under `domain/`: `tsera dev` will keep migrations, docs, and tests in sync.
- Copy `app/routes/health.route.ts` to create additional REST routes.
- Use Fresh components to consume the API and share the types generated by TSera.
- Pin Hono with `deno add npm:hono@4` when you have internet access; the local fallback in
  `deps/hono.ts` covers offline scenarios.

Happy building!
