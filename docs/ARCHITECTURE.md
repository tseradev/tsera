# TSera architecture

This note describes the internal layout of the TSera engine, the dependency graph (DAG)
orchestrating artifact generation, and how Continuous Coherence (CC) is guaranteed through the
`plan` and `apply` flows.

## Overview

TSera relies on a single model: **entities**. Each entity becomes multiple artifacts (Zod schemas,
OpenAPI documents, SQL migrations, Markdown docs, smoke tests). The CLI engine watches the project
and maintains a coherent state in `.tsera/` via a deterministic DAG.

```
     ┌─────────────┐
     │  EntityDef  │
     └──────┬──────┘
            │ defineEntity
            ▼
  ┌─────────────────────┐
  │   DAG root (entity) │
  └──────┬──────┬──────┘
         │      │
 ┌───────▼──┐ ┌─▼────────┐
 │ schema   │ │ openapi  │
 └────┬─────┘ └─────┬────┘
      │             │
┌─────▼──────┐ ┌────▼───────┐
│ migration  │ │ docs/test  │
└────────────┘ └────────────┘
```

Each node produces an artifact and stores its hash (content + options + CLI version) in
`.tsera/graph.json`. The `.tsera/manifest.json` file references generated outputs to keep diffs
stable.

## Continuous Coherence (CC)

CC is TSera's core principle: **every entity change must propagate automatically**. To achieve it:

1. **Observe**: `watch.ts` listens to relevant files (entities, config, templates) and groups
   changes.
2. **Plan**: `planner.ts` compares current hashes with the previous state and computes a list of
   steps (`create`, `update`, `delete`, `noop`).
3. **Apply**: `applier.ts` executes those steps with `safeWrite` so files are only written when a
   diff is detected, ensuring clean commits.
4. **Report**: `--json` outputs surface incoherences in automated pipelines (`coherence` events,
   exit code 2 in `--strict` mode).

This cycle keeps generated artifacts, migrations, and tests aligned with the source of truth.

## `plan` and `apply` flows

The CLI engine exposes two distinct phases, even if `dev` can chain them automatically:

1. **Plan**
   - Rebuilds the DAG and computes the required changes.
   - Provides a summary (`plan:summary`) listing affected artifacts per entity.
   - Supports `--json` mode for programmatic inspection (CI, dashboards).
2. **Apply**
   - Executes the steps computed by the current plan.
   - Writes files (`*.schema.ts`, `openapi.json`, `drizzle/` migrations, docs/tests) through
     `safeWrite`.
   - Updates `.tsera/graph.json` and `.tsera/manifest.json`.

These flows are orchestrated by `engine/dag.ts`, `engine/hash.ts`, `engine/planner.ts`, and
`engine/applier.ts`. When `dev` runs, it performs the following sequence:

1. `watch:start` (watcher initialization).
2. `plan:start` → `plan:summary` (step computation).
3. `apply:step` (apply each step) → `apply:done`.
4. `coherence` (final status: `ok`, `drift`, `error`).

## Handling multiple flows

- **`init`**: bootstraps a project and generates a full `tsera.config.ts`. No plan/apply is
  executed, but the `.tsera/` structure is prepared.
- **`dev`**: loops through the `plan/apply` duo. Ideal for CC.
- **`doctor`**: inspects incoherences. With `--fix`, it triggers a targeted `plan/apply` for the
  identified nodes.
- **`update`**: manages binary and dependency updates (`deno install`, `deno compile`).

## Persistent state

- `.tsera/graph.json`: DAG representation, node hashes, and dependencies.
- `.tsera/manifest.json`: inventory of generated files (paths, updated timestamps, disk hash).
- `drizzle/`: generated SQL migrations with stable timestamps.
- `docs/`: synchronized documentation derived from entities.

These elements allow restarting a `dev` cycle without losing artifact history.

## Entity definition

- Entities are described through `defineEntity` (`src/core/entity.ts`).
- Each entity has a PascalCase name, a `table` flag (for migrations), and a column dictionary
  (`TColumn`).
- Helpers `schema.ts`, `openapi.ts`, and `drizzle.ts` turn the model into typed artifacts.
- An entity can enable documentation generation (`doc: true`) or a smoke test (`test: "smoke"`).

The `templates/app-minimal/domain/User.entity.ts` file illustrates the expected structure. Future
iterations will add extra constraints (relationships, indexes) while staying backward compatible.

## Project configuration (`tsera.config.ts`)

The `tsera.config.ts` file generated by `tsera init` follows a compact, toggle-based contract:

1. Feature switches (`openapi`, `docs`, `tests`, `telemetry`).
2. Output directory (`outDir`) storing schemas, OpenAPI artefacts, and manifests.
3. Source discovery through `paths.entities` (directories or explicit entity files) and optional
   `paths.routes` hints.
4. Database profile (`db`) using the union `postgres|mysql|sqlite` with environment-driven URLs or
   local file paths.
5. Deployment surface (`deploy`) describing the runtime target and entrypoint.

`src/cli/core/resolve-config.ts` validates this structure with Zod, producing the internal shape
consumed by the engine. Any configuration change triggers a full DAG rebuild to guarantee alignment.

## Error handling and coherence

- **Validation**: Zod errors are aggregated and surfaced through `plan:summary` with
  `status:
  "error"`.
- **Drift**: when a generated file is edited manually, its hash diverges and `coherence` becomes
  `drift`. In `--strict` mode, the CLI returns exit code 2.
- **Crash safety**: `applier.ts` writes files to a temporary directory before moving them atomically
  to avoid partial artifacts.

`.tsera/manifest.json` stores the metadata needed to compare disk state and computed state.

## CLI interfaces & execution modes

- **TUI** (default): displays steps, hashes, and a summary in real time.
- **JSON mode** (`--json`): every stage emits an NDJSON line, perfect for CI/CD scripts.
- **Strict mode** (`--strict`): blocks persistent drift; useful as a gatekeeper.

Future versions will expose `plan`/`apply` commands directly to ease custom pipelines. Until then,
`tsera dev --json` remains the recommended mode for continuous integration.
