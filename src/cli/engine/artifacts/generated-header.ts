import { join } from "../../../shared/path.ts";

export type GeneratedTextFormat = "ts" | "md" | "sql";

export type GeneratedHeaderOptions = {
  projectDir: string;
  targetPath: string;
  format: GeneratedTextFormat;
  source: string;
  body: string;
};

const TS_HEADER_START = "// -----------------------------------------------------------------------------";
const TS_HEADER_END = "// -----------------------------------------------------------------------------";
const SQL_HEADER_START = "-- -----------------------------------------------------------------------------";
const SQL_HEADER_END = "-- -----------------------------------------------------------------------------";

/**
 * Applies a deterministic auto-generated header to text artifacts.
 *
 * The header timestamp is preserved when the body content is unchanged
 * to keep outputs stable across runs.
 */
export async function applyGeneratedTextHeader(
  options: GeneratedHeaderOptions,
): Promise<string> {
  const absolutePath = join(options.projectDir, options.targetPath);
  const existing = await readTextFileIfExists(absolutePath);

  let generatedAt = new Date().toISOString();
  if (existing) {
    const split = splitHeader(existing, options.format);
    if (split.body === options.body && split.generatedAt) {
      generatedAt = split.generatedAt;
    }
  }

  const header = buildHeader(options.format, generatedAt, options.source);
  return header + options.body;
}

function buildHeader(format: GeneratedTextFormat, generatedAt: string, source: string): string {
  if (format === "md") {
    return [
      "<!--",
      "  This file is auto-generated by TSera. Do not edit manually.",
      `  Generated at: ${generatedAt}`,
      `  Source: ${source}`,
      "-->",
      "",
    ].join("\n");
  }

  if (format === "sql") {
    return [
      SQL_HEADER_START,
      "-- This file is auto-generated by TSera. Do not edit manually.",
      `-- Generated at: ${generatedAt}`,
      `-- Source: ${source}`,
      SQL_HEADER_END,
      "",
    ].join("\n");
  }

  return [
    TS_HEADER_START,
    "// This file is auto-generated by TSera. Do not edit manually.",
    `// Generated at: ${generatedAt}`,
    `// Source: ${source}`,
    TS_HEADER_END,
    "",
  ].join("\n");
}

function splitHeader(
  content: string,
  format: GeneratedTextFormat,
): { body: string; generatedAt?: string } {
  if (format === "md") {
    if (!content.startsWith("<!--")) {
      return { body: content };
    }
    const endIndex = content.indexOf("-->");
    if (endIndex === -1) {
      return { body: content };
    }
    const headerBlock = content.slice(0, endIndex + 3);
    let rest = content.slice(endIndex + 3);
    if (rest.startsWith("\n")) rest = rest.slice(1);
    if (rest.startsWith("\n")) rest = rest.slice(1);
    return { body: rest, generatedAt: extractGeneratedAt(headerBlock) };
  }

  const startMarker = format === "sql" ? SQL_HEADER_START : TS_HEADER_START;
  const endMarker = format === "sql" ? SQL_HEADER_END : TS_HEADER_END;

  if (!content.startsWith(startMarker)) {
    return { body: content };
  }
  const endIndex = content.indexOf(endMarker, startMarker.length);
  if (endIndex === -1) {
    return { body: content };
  }
  const headerBlock = content.slice(0, endIndex + endMarker.length);
  let rest = content.slice(endIndex + endMarker.length);
  if (rest.startsWith("\n")) rest = rest.slice(1);
  if (rest.startsWith("\n")) rest = rest.slice(1);
  return { body: rest, generatedAt: extractGeneratedAt(headerBlock) };
}

function extractGeneratedAt(header: string): string | undefined {
  const match = header.match(/Generated at:\s*(.+)/);
  return match ? match[1].trim() : undefined;
}

async function readTextFileIfExists(path: string): Promise<string | null> {
  try {
    return await Deno.readTextFile(path);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return null;
    }
    throw error;
  }
}
