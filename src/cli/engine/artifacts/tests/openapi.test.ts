import { assertEquals, assertStringIncludes } from "std/assert";
import { z } from "zod";
import { defineEntity } from "../../../../core/entity.ts";
import type { TseraConfig } from "../../../definitions.ts";
import { buildProjectOpenAPIArtifact } from "../openapi.ts";

const baseConfig: TseraConfig = {
  openapi: true,
  docs: true,
  tests: true,
  telemetry: false,
  outDir: ".tsera",
  paths: { entities: ["domain"] },
  db: {
    dialect: "postgres",
    urlEnv: "DATABASE_URL",
    ssl: "prefer",
  },
  deploy: {
    target: "deno_deploy",
    entry: "main.ts",
  },
};

const projectDir = Deno.cwd();

Deno.test("buildProjectOpenAPIArtifact - generates an OpenAPI document", async () => {
  const entity = defineEntity({
    name: "User",
    fields: {
      id: { validator: z.string(), visibility: "public" },
      email: { validator: z.string().email(), visibility: "public" },
    },
  });

  const artifact = await buildProjectOpenAPIArtifact([entity], baseConfig, projectDir);

  assertEquals(artifact !== null, true);
  assertEquals(artifact!.kind, "openapi");
  const normalizedPath = artifact!.path.replace(/\\/g, "/");
  assertEquals(normalizedPath, "docs/openapi/openapi.json");
  assertEquals(artifact!.label, "Project OpenAPI");
});

Deno.test("buildProjectOpenAPIArtifact - returns null when OpenAPI disabled", async () => {
  const entity = defineEntity({
    name: "User",
    fields: {
      id: { validator: z.string(), visibility: "public" },
    },
  });

  const configWithoutOpenAPI = { ...baseConfig, openapi: false };
  const artifact = await buildProjectOpenAPIArtifact([entity], configWithoutOpenAPI, projectDir);

  assertEquals(artifact, null);
});

Deno.test("buildProjectOpenAPIArtifact - includes entity metadata", async () => {
  const user = defineEntity({
    name: "User",
    fields: { id: { validator: z.string(), visibility: "public" } },
  });
  const post = defineEntity({
    name: "Post",
    fields: { id: { validator: z.string(), visibility: "public" } },
  });

  const artifact = await buildProjectOpenAPIArtifact([user, post], baseConfig, projectDir);

  assertEquals(artifact!.data?.entities, ["User", "Post"]);

  const parsed = parseJson(artifact!.content as string);
  const meta = readMeta(parsed);
  assertEquals(meta.entities, ["User", "Post"]);
  assertEquals(typeof meta.generatedAt, "string");
});

Deno.test("buildProjectOpenAPIArtifact - generates valid JSON", async () => {
  const entity = defineEntity({
    name: "Product",
    fields: {
      name: { validator: z.string(), visibility: "public" },
      price: { validator: z.number(), visibility: "public" },
    },
  });

  const artifact = await buildProjectOpenAPIArtifact([entity], baseConfig, projectDir);
  const parsed = parseJson(artifact!.content as string);

  assertEquals(parsed.openapi, "3.1.0");
  const meta = readMeta(parsed);
  assertEquals(meta.warning, "Auto-generated by TSera. Do not edit manually.");
});

Deno.test("buildProjectOpenAPIArtifact - filters entities with openapi.enabled === false", async () => {
  const visible = defineEntity({
    name: "Visible",
    fields: { id: { validator: z.string(), visibility: "public" } },
    openapi: { enabled: true },
  });
  const hidden = defineEntity({
    name: "Hidden",
    fields: { id: { validator: z.string(), visibility: "public" } },
    openapi: { enabled: false },
  });

  const artifact = await buildProjectOpenAPIArtifact([visible, hidden], baseConfig, projectDir);
  const parsed = parseJson(artifact!.content as string);
  const schemas = readSchemas(parsed);

  assertEquals(schemas.Visible !== undefined, true);
  assertEquals(schemas.Hidden === undefined, true);
});

Deno.test("buildProjectOpenAPIArtifact - filters non-public fields", async () => {
  const entity = defineEntity({
    name: "Test",
    fields: {
      id: { validator: z.string(), visibility: "public" },
      email: { validator: z.string().email(), visibility: "public" },
      password: { validator: z.string(), visibility: "secret" },
      internal: { validator: z.string(), visibility: "internal" },
    },
  });

  const artifact = await buildProjectOpenAPIArtifact([entity], baseConfig, projectDir);
  const parsed = parseJson(artifact!.content as string);
  const schemas = readSchemas(parsed);
  const schema = readSchema(schemas, "Test");
  const properties = readProperties(schema);

  assertEquals("id" in properties, true);
  assertEquals("email" in properties, true);
  assertEquals("password" in properties, false);
  assertEquals("internal" in properties, false);
});

Deno.test("buildProjectOpenAPIArtifact - creates schema dependencies", async () => {
  const user = defineEntity({
    name: "User",
    fields: { id: { validator: z.string(), visibility: "public" } },
  });
  const post = defineEntity({
    name: "Post",
    fields: { id: { validator: z.string(), visibility: "public" } },
  });

  const artifact = await buildProjectOpenAPIArtifact([user, post], baseConfig, projectDir);

  assertEquals(artifact!.dependsOn !== undefined, true);
  assertEquals(artifact!.dependsOn!.length, 2);

  const dep0 = artifact!.dependsOn![0].replace(/\\/g, "/");
  const dep1 = artifact!.dependsOn![1].replace(/\\/g, "/");

  assertStringIncludes(dep0, "schema:user:");
  assertStringIncludes(dep0, ".tsera/schemas/User.schema.ts");
  assertStringIncludes(dep1, "schema:post:");
  assertStringIncludes(dep1, ".tsera/schemas/Post.schema.ts");
});

function parseJson(content: string): Record<string, unknown> {
  const parsed: unknown = JSON.parse(content);
  if (!isRecord(parsed)) {
    throw new Error("OpenAPI content is not a JSON object.");
  }
  return parsed;
}

function readMeta(document: Record<string, unknown>): {
  entities?: unknown;
  generatedAt?: unknown;
  warning?: unknown;
} {
  const meta = document["x-tsera"];
  if (!isRecord(meta)) {
    throw new Error("Missing x-tsera metadata in OpenAPI document.");
  }
  return {
    entities: meta["entities"],
    generatedAt: meta["generatedAt"],
    warning: meta["warning"],
  };
}

function readSchemas(document: Record<string, unknown>): Record<string, unknown> {
  const components = document["components"];
  if (!isRecord(components)) {
    throw new Error("Missing OpenAPI components section.");
  }
  const schemas = components["schemas"];
  if (!isRecord(schemas)) {
    throw new Error("Missing OpenAPI schemas section.");
  }
  return schemas;
}

function readSchema(
  schemas: Record<string, unknown>,
  name: string,
): Record<string, unknown> {
  const schema = schemas[name];
  if (!isRecord(schema)) {
    throw new Error(`Missing OpenAPI schema for ${name}.`);
  }
  return schema;
}

function readProperties(schema: Record<string, unknown>): Record<string, unknown> {
  const properties = schema["properties"];
  if (!isRecord(properties)) {
    throw new Error("Missing schema properties.");
  }
  return properties;
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}
