/**
 * Directory copying utilities for template composition.
 *
 * This module handles recursive directory copying with file exclusions
 * and file adaptation during copy process.
 *
 * @module
 */

import { exists } from "std/fs";
import { walk } from "std/fs/walk";
import { dirname, join, relative } from "../../../../shared/path.ts";
import { ensureDir, safeWrite } from "../../../utils/fsx.ts";
import { adaptConnectFile, adaptDrizzleConfigFile, adaptEntityImports } from "./file-adapter.ts";
import type { ComposedTemplate } from "./template-composer.ts";

/**
 * Extensions of binary files that should be copied as binary data.
 */
const BINARY_EXTENSIONS = [
  // Images
  ".png",
  ".jpg",
  ".jpeg",
  ".gif",
  ".svg",
  ".ico",
  ".webp",
  ".bmp",
  ".tiff",
  // Fonts
  ".woff",
  ".woff2",
  ".ttf",
  ".eot",
  ".otf",
  // Archives
  ".zip",
  ".tar",
  ".gz",
  ".7z",
  ".rar",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".xls",
  ".xlsx",
  ".ppt",
  ".pptx",
  // Media
  ".mp3",
  ".mp4",
  ".avi",
  ".mov",
  ".wav",
  ".ogg",
  ".webm",
];

/**
 * Determines if a file is binary based on its extension.
 *
 * @param filePath - Path to file
 * @returns True if file is binary
 */
function isBinaryFile(filePath: string): boolean {
  const ext = filePath.toLowerCase().slice(filePath.lastIndexOf("."));
  return BINARY_EXTENSIONS.includes(ext);
}

/**
 * Options for copying a directory.
 */
export type CopyDirectoryOptions = {
  /** Source directory to copy from. */
  source: string;
  /** Target directory to copy to. */
  target: string;
  /** Composition result to update. */
  result: ComposedTemplate;
  /** Whether to overwrite existing files. */
  force?: boolean;
};

/**
 * Copies a directory recursively to target.
 *
 * @param options - Copy options.
 */
export async function copyDirectory(
  options: CopyDirectoryOptions,
): Promise<void> {
  const { source, target, result, force = false } = options;

  for await (const entry of walk(source, { includeDirs: false })) {
    const relativePath = relative(source, entry.path);

    // Skip env.* files from template - they will be generated dynamically by generateEnvironmentFiles
    // Handle both Windows (\\) and Unix (/) path separators
    const pathSeparator = relativePath.includes("\\") ? "\\" : "/";
    const parts = relativePath.split(pathSeparator);
    const lastPart = parts[parts.length - 1];
    if (
      lastPart === "env.example" || lastPart === "env.dev" ||
      lastPart === "env.staging" || lastPart === "env.prod"
    ) {
      // Skip these files - they will be generated by generateEnvironmentFiles
      continue;
    }

    // Skip deno.jsonc from Lume module - it's merged with base deno.jsonc via config-merger.ts
    if (source.includes("lume") && lastPart === "deno.jsonc") {
      continue;
    }

    // Skip .vscode/ from Lume module - it's copied to project root by generateLumeProject
    const isVscodeFile = relativePath.startsWith(".vscode/") ||
      relativePath.startsWith(".vscode\\");
    if (source.includes("lume") && isVscodeFile) {
      continue;
    }

    // Skip _config.ts from Lume module - it's copied to config/front/ by generateLumeProject
    if (source.includes("lume") && lastPart === "_config.ts") {
      continue;
    }

    // Special handling for env.config.ts from base template: should go to config/
    let targetPath = join(target, relativePath);
    if (lastPart === "env.config.ts" && relativePath === lastPart) {
      // File is at root of base template, place it in config/
      targetPath = join(target, "config", "env.config.ts");
    }

    // Special handling for docker module: all files should go to config/docker/
    const isDockerModule = source.includes("docker") && !source.includes("config/docker");
    if (isDockerModule) {
      // File is from docker module, place it in config/docker/
      targetPath = join(target, "config", "docker", lastPart);
    }

    // Special handling for secrets module: env.config.ts should go to config/secret/
    const isSecretsModule = source.includes("secrets") && !source.includes("secrets/config");
    const isEnvConfigFile = lastPart === "env.config.ts";

    if (isSecretsModule && isEnvConfigFile && relativePath === lastPart) {
      // File is at root of secrets module, place it in config/secret/
      targetPath = join(target, "config", "secret", lastPart);
    }

    // Skip deps files if they already exist (shared between modules)
    if (relativePath.startsWith("deps/") || relativePath.startsWith("deps\\")) {
      if (await exists(targetPath) && !force) {
        result.skippedFiles.push(relativePath);
        continue;
      }
    }

    // Check if file already exists
    if (await exists(targetPath) && !force) {
      result.skippedFiles.push(relativePath);
      continue;
    }

    // Ensure target directory exists
    await ensureDir(dirname(targetPath));

    // Check if file is binary and use appropriate read/write methods
    if (isBinaryFile(relativePath)) {
      // Copy binary file directly without adaptation
      const binaryContent = await Deno.readFile(entry.path);
      await safeWrite(targetPath, binaryContent);
    } else {
      // Read file content to potentially adapt it
      let content = await Deno.readTextFile(entry.path);

      // Adapt connect.ts to uncomment database imports if dependencies are available
      if (relativePath === "app/db/connect.ts" || relativePath.endsWith("/connect.ts")) {
        content = await adaptConnectFile(content, target);
      }

      // Adapt drizzle.config.ts to uncomment drizzle-kit import if drizzle-kit is installed
      if (
        relativePath === "config/db/drizzle.config.ts" ||
        relativePath.endsWith("/drizzle.config.ts")
      ) {
        content = await adaptDrizzleConfigFile(content, target);
      }

      // Adapt entity files to transform relative imports to tsera/ imports
      // Detect entity files: files ending with .entity.ts or in entities/ or domain/ directories
      const isEntityFile = relativePath.endsWith(".entity.ts") ||
        relativePath.includes("/entities/") ||
        relativePath.includes("\\entities\\") ||
        relativePath.includes("/domain/") ||
        relativePath.includes("\\domain\\");

      if (isEntityFile) {
        content = adaptEntityImports(content, target);
      }

      // Write adapted content
      await safeWrite(targetPath, content);
    }

    // Use actual target path relative to project root for copiedFiles
    let copiedPath = relativePath;
    if (lastPart === "env.config.ts" && relativePath === lastPart) {
      copiedPath = `config/env.config.ts`;
    } else if (isDockerModule) {
      copiedPath = `config/docker/${lastPart}`;
    } else if (isSecretsModule && isEnvConfigFile && relativePath === lastPart) {
      copiedPath = `config/secret/${lastPart}`;
    }
    result.copiedFiles.push(copiedPath);
  }
}
