/**
 * Directory copying utilities for template composition.
 *
 * This module handles recursive directory copying with file exclusions
 * and file adaptation during the copy process.
 *
 * @module
 */

import { dirname, join, relative } from "../../../../shared/path.ts";
import { exists } from "std/fs";
import { walk } from "std/fs/walk";
import { ensureDir } from "../../../utils/fsx.ts";
import type { ComposedTemplate } from "./template-composer.ts";
import { adaptConnectFile, adaptDrizzleConfigFile, adaptEntityImports } from "./file-adapter.ts";

/**
 * Extensions of binary files that should be copied as binary data.
 */
const BINARY_EXTENSIONS = [
  // Images
  ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".webp", ".bmp", ".tiff",
  // Fonts
  ".woff", ".woff2", ".ttf", ".eot", ".otf",
  // Archives
  ".zip", ".tar", ".gz", ".7z", ".rar",
  // Documents
  ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
  // Media
  ".mp3", ".mp4", ".avi", ".mov", ".wav", ".ogg", ".webm",
];

/**
 * Determines if a file is binary based on its extension.
 *
 * @param filePath - Path to the file
 * @returns True if the file is binary
 */
function isBinaryFile(filePath: string): boolean {
  const ext = filePath.toLowerCase().slice(filePath.lastIndexOf("."));
  return BINARY_EXTENSIONS.includes(ext);
}

/**
 * Options for copying a directory.
 */
export interface CopyDirectoryOptions {
  /** Source directory to copy from. */
  source: string;
  /** Target directory to copy to. */
  target: string;
  /** Composition result to update. */
  result: ComposedTemplate;
  /** Whether to overwrite existing files. */
  force?: boolean;
}

/**
 * Copies a directory recursively to the target.
 *
 * @param options - Copy options.
 */
export async function copyDirectory(
  options: CopyDirectoryOptions,
): Promise<void> {
  const { source, target, result, force = false } = options;

  for await (const entry of walk(source, { includeDirs: false })) {
    const relativePath = relative(source, entry.path);

    // Skip env.* files from template - they will be generated dynamically by generateEnvironmentFiles
    // Handle both Windows (\\) and Unix (/) path separators
    const pathSeparator = relativePath.includes("\\") ? "\\" : "/";
    const parts = relativePath.split(pathSeparator);
    const lastPart = parts[parts.length - 1];
    if (
      lastPart === "env.example" || lastPart === "env.dev" ||
      lastPart === "env.staging" || lastPart === "env.prod"
    ) {
      // Skip these files - they will be generated by generateEnvironmentFiles
      continue;
    }

    // Skip deno.jsonc from Lume module - it's merged with base deno.jsonc via config-merger.ts
    if (source.includes("lume") && lastPart === "deno.jsonc") {
      continue;
    }

    // Skip .vscode/ from Lume module - it's copied to project root by generateLumeProject
    const isVscodeFile = relativePath.startsWith(".vscode/") || relativePath.startsWith(".vscode\\");
    if (source.includes("lume") && isVscodeFile) {
      continue;
    }

    // Special handling for secrets module: manager.ts and manager.test.ts should go to config/secrets/
    let targetPath = join(target, relativePath);
    const isSecretsModule = source.includes("secrets") && !source.includes("secrets/config");
    const isManagerFile = lastPart === "manager.ts" || lastPart === "manager.test.ts";

    if (isSecretsModule && isManagerFile && relativePath === lastPart) {
      // File is at root of secrets module, place it in config/secrets/
      targetPath = join(target, "config", "secrets", lastPart);
    }

    // Special handling for Lume module: assets/ directory should be copied as static/
    const isLumeModule = source.includes("lume");
    const isAssetsPath = relativePath.startsWith("assets/") || relativePath.startsWith("assets\\");
    if (isLumeModule && isAssetsPath) {
      // Replace assets/ or assets\ with static/ in the target path
      // Use string replace instead of regex to avoid escaping issues
      if (relativePath.startsWith("assets/")) {
        targetPath = join(target, relativePath.replace("assets/", "static/"));
      } else {
        targetPath = join(target, relativePath.replace("assets\\", "static\\"));
      }
    }

    // Skip deps files if they already exist (shared between modules)
    if (relativePath.startsWith("deps/") || relativePath.startsWith("deps\\")) {
      if (await exists(targetPath) && !force) {
        result.skippedFiles.push(relativePath);
        continue;
      }
    }

    // Check if file already exists
    if (await exists(targetPath) && !force) {
      result.skippedFiles.push(relativePath);
      continue;
    }

    // Ensure target directory exists
    await ensureDir(dirname(targetPath));

    // Check if file is binary and use appropriate read/write methods
    if (isBinaryFile(relativePath)) {
      // Copy binary file directly without adaptation
      const binaryContent = await Deno.readFile(entry.path);
      await Deno.writeFile(targetPath, binaryContent);
    } else {
      // Read file content to potentially adapt it
      let content = await Deno.readTextFile(entry.path);

      // Adapt connect.ts to uncomment database imports if dependencies are available
      if (relativePath === "app/db/connect.ts" || relativePath.endsWith("/connect.ts")) {
        content = await adaptConnectFile(content, target);
      }

      // Adapt drizzle.config.ts to uncomment drizzle-kit import if drizzle-kit is installed
      if (
        relativePath === "config/db/drizzle.config.ts" || relativePath.endsWith("/drizzle.config.ts")
      ) {
        content = await adaptDrizzleConfigFile(content, target);
      }

      // Adapt entity files to transform relative imports to tsera/ imports
      // Detect entity files: files ending with .entity.ts or in entities/ or domain/ directories
      const isEntityFile = relativePath.endsWith(".entity.ts") ||
        relativePath.includes("/entities/") ||
        relativePath.includes("\\entities\\") ||
        relativePath.includes("/domain/") ||
        relativePath.includes("\\domain\\");

      if (isEntityFile) {
        content = adaptEntityImports(content, target);
      }

      // Write adapted content
      await Deno.writeTextFile(targetPath, content);
    }

    // Use the actual target path relative to project root for copiedFiles
    let copiedPath = relativePath;
    if (isSecretsModule && isManagerFile && relativePath === lastPart) {
      copiedPath = `config/secrets/${lastPart}`;
    } else if (isLumeModule && isAssetsPath) {
      // Record as static/ instead of assets/
      // Use string replace instead of regex to avoid escaping issues
      if (relativePath.startsWith("assets/")) {
        copiedPath = relativePath.replace("assets/", "static/");
      } else {
        copiedPath = relativePath.replace("assets\\", "static\\");
      }
    }
    result.copiedFiles.push(copiedPath);
  }
}
