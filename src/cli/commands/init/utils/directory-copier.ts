/**
 * Directory copying utilities for template composition.
 *
 * This module handles recursive directory copying with file exclusions
 * and file adaptation during the copy process.
 *
 * @module
 */

import { dirname, join, relative } from "../../../../shared/path.ts";
import { exists } from "std/fs";
import { walk } from "std/fs/walk";
import { ensureDir } from "../../../utils/fsx.ts";
import type { ComposedTemplate } from "./template-composer.ts";
import { adaptConnectFile, adaptDrizzleConfigFile, adaptEntityImports } from "./file-adapter.ts";

/**
 * Options for copying a directory.
 */
export interface CopyDirectoryOptions {
  /** Source directory to copy from. */
  source: string;
  /** Target directory to copy to. */
  target: string;
  /** Composition result to update. */
  result: ComposedTemplate;
  /** Whether to overwrite existing files. */
  force?: boolean;
}

/**
 * Copies a directory recursively to the target.
 *
 * @param options - Copy options.
 */
export async function copyDirectory(
  options: CopyDirectoryOptions,
): Promise<void> {
  const { source, target, result, force = false } = options;

  for await (const entry of walk(source, { includeDirs: false })) {
    const relativePath = relative(source, entry.path);

    // Skip env.* files from template - they will be generated dynamically by generateEnvironmentFiles
    // Handle both Windows (\\) and Unix (/) path separators
    const pathSeparator = relativePath.includes("\\") ? "\\" : "/";
    const parts = relativePath.split(pathSeparator);
    const lastPart = parts[parts.length - 1];
    if (
      lastPart === "env.example" || lastPart === "env.dev" ||
      lastPart === "env.staging" || lastPart === "env.prod"
    ) {
      // Skip these files - they will be generated by generateEnvironmentFiles
      continue;
    }

    // Special handling for secrets module: manager.ts and manager.test.ts should go to config/secrets/
    let targetPath = join(target, relativePath);
    const isSecretsModule = source.includes("secrets") && !source.includes("secrets/config");
    const isManagerFile = lastPart === "manager.ts" || lastPart === "manager.test.ts";

    if (isSecretsModule && isManagerFile && relativePath === lastPart) {
      // File is at root of secrets module, place it in config/secrets/
      targetPath = join(target, "config", "secrets", lastPart);
    }

    // Special handling for Lume module: assets/ directory should be copied as static/
    const isLumeModule = source.includes("lume");
    const isAssetsPath = relativePath.startsWith("assets/") || relativePath.startsWith("assets\\");
    if (isLumeModule && isAssetsPath) {
      // Replace assets/ or assets\ with static/ in the target path
      // Use string replace instead of regex to avoid escaping issues
      if (relativePath.startsWith("assets/")) {
        targetPath = join(target, relativePath.replace("assets/", "static/"));
      } else {
        targetPath = join(target, relativePath.replace("assets\\", "static\\"));
      }
    }

    // Skip deps files if they already exist (shared between modules)
    if (relativePath.startsWith("deps/") || relativePath.startsWith("deps\\")) {
      if (await exists(targetPath) && !force) {
        result.skippedFiles.push(relativePath);
        continue;
      }
    }

    // Check if file already exists
    if (await exists(targetPath) && !force) {
      result.skippedFiles.push(relativePath);
      continue;
    }

    // Ensure target directory exists
    await ensureDir(dirname(targetPath));

    // Read file content to potentially adapt it
    let content = await Deno.readTextFile(entry.path);

    // Adapt connect.ts to uncomment database imports if dependencies are available
    if (relativePath === "app/db/connect.ts" || relativePath.endsWith("/connect.ts")) {
      content = await adaptConnectFile(content, target);
    }

    // Adapt drizzle.config.ts to uncomment drizzle-kit import if drizzle-kit is installed
    if (
      relativePath === "config/db/drizzle.config.ts" || relativePath.endsWith("/drizzle.config.ts")
    ) {
      content = await adaptDrizzleConfigFile(content, target);
    }

    // Adapt entity files to transform relative imports to tsera/ imports
    // Detect entity files: files ending with .entity.ts or in entities/ or domain/ directories
    const isEntityFile = relativePath.endsWith(".entity.ts") ||
      relativePath.includes("/entities/") ||
      relativePath.includes("\\entities\\") ||
      relativePath.includes("/domain/") ||
      relativePath.includes("\\domain\\");

    if (isEntityFile) {
      content = adaptEntityImports(content, target);
    }

    // Write adapted content
    await Deno.writeTextFile(targetPath, content);

    // Use the actual target path relative to project root for copiedFiles
    let copiedPath = relativePath;
    if (isSecretsModule && isManagerFile && relativePath === lastPart) {
      copiedPath = `config/secrets/${lastPart}`;
    } else if (isLumeModule && isAssetsPath) {
      // Record as static/ instead of assets/
      // Use string replace instead of regex to avoid escaping issues
      if (relativePath.startsWith("assets/")) {
        copiedPath = relativePath.replace("assets/", "static/");
      } else {
        copiedPath = relativePath.replace("assets\\", "static\\");
      }
    }
    result.copiedFiles.push(copiedPath);
  }
}
