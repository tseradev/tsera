# TSera

> Full TypeScript ¬∑ Unification ¬∑ Simplicity ¬∑ Automation ¬∑ Continuous Coherence (CC)

TSera is a CLI engine and entity core for Deno v2 projects that delivers **continuous coherence**
and **automated artifacts** (Zod schemas, OpenAPI definitions, Drizzle migrations, docs, tests) from
a single source of truth. The goal is to provide Deno-first tooling where every declared entity
stays aligned with the application from the `plan` phase to the final `apply`.

## Product promise

1. **A single source** (`defineEntity`) describes the domain model.
2. **A CLI engine** turns that model into ready-to-use artifacts (API, migrations, docs, tests).
3. **Continuous coherence** keeps those artifacts synchronized without manual effort.

TSera aims to shrink the time between an entity idea and its availability across code, database, and
team-facing documentation.

## Current stack

- **Deno v2** (strict ESM, tasks managed via `deno.jsonc`).
- **Cliffy** for the modular CLI (`init`, `dev`, `doctor`, `update`).
- **Zod**, **zod-to-openapi**, and **Drizzle** to project entities.
- **TS-Morph** to drive TypeScript generation.
- **Hono/Fresh templates** to bootstrap the `app-minimal` project.

## Quick start

```bash
# 1. Format the repository
deno task fmt
# 2. Run strict linting
deno task lint
# 3. Execute the test suite
deno task test
```

Once the CLI core is ready, the following commands will showcase the end-to-end workflow:

```bash
# Initialize a new project
deno run -A src/cli/main.ts init my-app
# Regenerate artifacts with continuous watching
deno run -A src/cli/main.ts dev
```

## Documentation

- [Detailed architecture guide](./docs/ARCHITECTURE.md)
- [Community landing & resources](./docs/README.md)
- [Communication playbook & assets](./docs/COMMUNICATION.md)

## Release & distribution

Official releases follow this sequence:

1. Create a `vX.Y.Z` tag and push it to the remote repository.
2. Run the multi-platform compilation:
   ```bash
   deno compile -A --output dist/tsera src/cli/main.ts
   ```
3. Publish the binaries on the GitHub release.
4. (Optional) Publish the JSR module:
   ```bash
   deno publish
   ```

An automated script will eventually package and publish binaries (Linux, macOS, Windows) and, when
enabled, push the `jsr:tsera` package.

### Preparing a stable tag

Before every release:

1. Validate local coherence:
   ```bash
   deno task fmt && deno task lint && deno task test
   ```
2. Run a full `dev` cycle in an example project generated with `tsera init demo`.
3. Update version numbers in `deno.jsonc`, `src/cli/main.ts`, and the documentation.
4. Draft a concise changelog (section `## Release vX.Y.Z` in `docs/COMMUNICATION.md`).
5. Prepare communication assets (thread script, ready-to-post messages) and plan the upcoming visual
   capture.

After completing these checks, create the `vX.Y.Z` tag and follow the release procedure above.

## Continuous coherence workflow

1. **Observe** ‚Äî `watch.ts` aggregates changes on entities and the configuration.
2. **Plan** ‚Äî `planner.ts` computes the steps (`create`, `update`, `delete`, `noop`).
3. **Apply** ‚Äî `applier.ts` writes artifacts with `safeWrite` and updates `.tsera/`.
4. **Report** ‚Äî `--json` outputs describe the status (`coherence: ok/drift/error`).

The cycle can run manually (`plan/apply`) or automatically through `tsera dev`.

## CLI commands (preview)

| Command                | Quick description                                                                  | Status    |
| ---------------------- | ---------------------------------------------------------------------------------- | --------- |
| `tsera init <name>`    | Generates `tsera.config.ts`, the `app-minimal` template, and the `.tsera/` layout. | üõ†Ô∏è In dev |
| `tsera dev [--json]`   | Watches entities, computes the plan, and applies artifacts on a loop.              | üõ†Ô∏è In dev |
| `tsera doctor [--fix]` | Diagnoses inconsistencies and can safely fix known scenarios.                      | üõ†Ô∏è In dev |
| `tsera update`         | Updates the installed binary and syncs CLI dependencies.                           | üõ†Ô∏è In dev |

Each command supports an interactive mode (`TUI`) and machine-oriented mode (`--json`). Detailed
option specifications will be added once the implementation stabilizes.

## Repository structure

```text
.
‚îú‚îÄ src/               # TypeScript core (entities, Cliffy CLI, plan/apply engine)
‚îú‚îÄ templates/         # Example projects generated by `tsera init`
‚îú‚îÄ docs/              # Technical documentation, communication notes, release material
‚îú‚îÄ scripts/           # Automation (E2E, release, utilities)
‚îú‚îÄ deno.jsonc         # Deno task configuration and lint/formatter rules
‚îî‚îÄ import_map.json    # Local development import aliases
```

## Contributing

1. Fork the repository and create a `feat/...` or `docs/...` branch.
2. Implement the change while following the constraints listed in [`AGENTS.md`](./AGENTS.md).
3. Run the local checks (`deno task fmt`, `deno task lint`, `deno task test`).
4. Open a PR with a `[scope] Concise description` title and a clear summary.

For any discussion or proposal, open an issue or reach out via the channels listed in
`docs/COMMUNICATION.md`.

## Immediate roadmap

1. Finalize `defineEntity` and the Zod/OpenAPI/Drizzle helpers.
2. Stabilize the Cliffy CLI with the `init`, `dev`, `doctor`, `update` commands.
3. Ship the complete `app-minimal` template with generated artifacts.
4. Enable the E2E flow (`scripts/e2e.ts`).
5. Publish an experimental binary for early feedback.
